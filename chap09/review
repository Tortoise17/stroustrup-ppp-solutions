1. What are the two parts of a class, as described in the chapter?
    Interface and Implementation

2. What is the difference between the interface and the implementation
in a class?
    Interface: directly accessible by users
    Implementation: Hidden and used indirectly by users

3. What are the limitations and problems of the original Date struct
that is created in the chapter?
    Allowed invalid y, m, d values

4. Why is a constructor used for the Date type instead of an init_day()
function?
    - Called immediately when class is instaniated
    - Catches errors on erroneous instantiating

5. What is an invariant? Give examples.
    Conditions that hold true throughout the program
    Eg:
        Age must be +ve;
        Velocity v must be <= c

6. When should functions be put in the class definition, and when
should they be defined outside the class? Why?
    Inside: Simple logic and less no. of lines
    Outside: Not straightforward and long implementation

7. When should operator overloading be used in a program? Give a list
of operators that you might want to overload (each with a reason)
    Define operations for class and enum types
    - Only when required and makes sense
    - Make use of conventional meanings (non obscure)

    Eg: Overloading == for class to compare class types based on properties
        overloading != to !(a==b)

8. Why should the public interface to a class be as small as possible?
    Harder to find members in large definition

9. What does adding const to a member function do?
    Allow member function to be called for const object

10. Why are “helper functions” best placed outside the class definition?
    They are design concepts - different from programming logic