#include <iostream>

class Y {
public:
    Y(int x, int y);
    Y(int x);
};

class Base {
public:
    Base();
    void f();
};

class Der : public Base {
public:
    Der();
};

// void modify(int* x) {
//     *x = 10;
// }

void fn(Base& b) {}

int main() {
    // int var = 10;
    // int var2 = 10;
    // int* ptr1 = &var;
    // int* ptr2 = &var2;

    // *ptr1 = 12;
    // // int x = ptr1; // error
    // // int* x = var; // error

    // std::cout << *ptr1 << *ptr2;

    // double* p0 = new double[4]; // the doubles may be uninitialized (when not in debug mode)
    // X* px = new X[10]; // If X has default constructor, all X objects allocated are initialized using it
    // X* px1 = new X; // X allocated is initialized if it has a default constructor

    // If a type Y has no default constructor
    // Y* py = new Y; // error no default constructor
    Y* py1 = new Y{10}; // ok
    // Y* py3 = new Y[5]; // error no default constructor
    Y* py4 = new Y[5] {1,2,3,4,5}; // ok
    Y* py4 = new Y[5] {{0,1},{1,2}, {3,4},{4,5},{5,6}}; // ok


    double* p = new double {5.5};
    
    // double* p1;
    // *p1 = 12; // dangerous (we don't know where p1 points to)

    double* p2 = new double[5] {1,2,3,4,5};
    delete p; // ok
    delete p2; // only deletes double[0]
    delete[] p2; // deletes all allocated doubles
    // delete[] p2; // error: freeing already deleted memory

    double* p3 = nullptr;
    delete p3; // ok: deleting nullptr
    delete p3; // still ok

    // if(p3) // eqv to if(p3 != nullptr)
    // if destructor is not declared for a class, an automatic destructor is generated by the compiler
    // to destruct the members of that class (the generated destructor is not virtual)

    // Because delete invokes destructors (for types, such as vector, that have one), 
    // delete is often said to destroy objects, not just deallocate them.

    // void* pv = new int[10]; // ok

    int* pi = new int[10];
    void* pv = pi;

    // int* p4 = pv; // error
    // double* p5 = pv; // error
    // *pv = 10; // error
    // pv[2] = 1; // error (cannot subscript void*)

    int* pi = static_cast<int*>(pv); // ok
    // int a = 1;
    // modify(&a);

    Der d;
    Base& b = d; // ok
    Base* p6 = new Der;
    fn(*p6); // ok

    // int* pii = nullptr;
    // *pii = 1; // error

    // Base* pb = nullptr;
    // pb->f(); // error

    
}